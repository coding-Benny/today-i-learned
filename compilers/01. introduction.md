*본 포스팅은 Stanford CS 143: Compilers 수강 내용을 바탕으로 작성하였습니다.*
# Compilers vs Interpreter
이 수업에서는 주로 컴파일러(Compilers)에 대해 다루겠지만, 인터프리터(Interpreters)에 대해서도 함께 잠깐 짚고 넘어가자.
## Compilers
<img src="https://miro.medium.com/max/788/1*sm_R_Zl9B_5eKTES1QftGw.png" width="500" alt="compiler">

프로그램을 입력하면 컴파일러가 **한 번에 기계어로 번역**하여 실행 파일을 만들어내고, 이 실행 파일 프로그램은 어셈블리(assembly)나 바이트 코드(bytecode) 등 다양한 언어로 작성될 수 있으며, 데이터를 개별적으로 넣어 결과물을 만들어내는 구조이다. 즉, 컴파일러는 실행 파일을 생성하는 전처리 단계이며, 이후 프로그램의 다른 처리를 위해 **재 컴파일할 필요 없이** 동일한 실행파일을 다양한 데이터를 주입하여 실행할 수 있다. 일종의 off-line 상태라고 볼 수 있다. 앞에서 언급한 한 번에 기계어로 번역하고 재 컴파일이 필요 없다는 점에서 인터프리터보다 상대적으로 **실행 속도가 빠르다**는 특징이 있다.

## Interpreters
<img src="https://miro.medium.com/max/788/1*U4YBq7pK9VrDOclBYbcOZA.png" width="500" alt="interpreter">

인터프리터는 컴파일러와는 달리, 프로그램을 입력하고 실행하고자 하는 모든 데이터를 넣으면 직접 결과를 출력하기 때문에 프로그램이 입력해서 실제로 실행되기 전까지는 프로그램을 전혀 처리하지 않는다. 그저 프로그램을 작성하고 데이터에 대한 **인터프리터를 호출하면 즉시 프로그램을 실행**할 뿐이다. 즉, 인터프리터가 하는 모든 작업은 프로그램 실행의 일부이므로 on-line 상태라고 말할 수 있다.

# Structure of a Compiler
그럼 이제 인간이 문장을 어떻게 이해하는지와 연결지어서 컴파일러가 어떻게 낱말 분석(Lexical Analysis), 구문 분석(Parsing), 의미 분석(Semantic Analysis), 최적화(Optimization), 코드 생성(Code Generation)을 이해하는지 살펴보자.
<img src="https://miro.medium.com/max/788/0*dC9f5yewc0Au6oeh.jpg" width="500" alt="phase of a compiler"><br>
<em>“Phase of a Compiler”. (2020). GeeksforGeeks. https://www.geeksforgeeks.org/phases-of-a-compiler</em>

> This is a sentence.

그 첫 단계는 바로 **단어를 인식**하는 것이다. 예를 들어서 위의 문장을 보고 인간은 ‘This’, ‘is’, ‘a’, ‘sentence’라는 4개의 단어를 알아볼 수 있다. 너무나 자연스럽게 알아차리기 때문에 자신이 이에 대해 생각한다는 것을 자각하지는 못하지만, 실제로 공백과 구두점, 대문자 같은 단서들을 통해 사람들이 이해할 수 있는 단어들로 글자를 나누는데 도움을 준다. 이를 당연한 것 또는 사소한 것이라고 생각할 수 있다. 그렇다면 다음 문장은 어떨까?

> ist his ase nte nce

이 문장을 읽을 수는 있지만 익숙하지 않은 방식으로 띄어쓰기가 되어 있기 때문에 실제 어디서 끊어 읽어야 하는지 확인하기 위한 추가적인 작업이 필요함에 따라 시간이 더 소요된다.

이렇게 사소하지 않은 **낱말 분석**은 프로그램 텍스트를 단어 또는 토큰(token)으로 나눈다.

`if x == y then z = 1; else z = 2;` 라는 프로그램 텍스트를 보고 토큰을 식별해보자. `if`, `then`, `else`와 같은 키워드(keyword)들과 x, y, z 같은 변수명, 1과 2 같은 상수들과 몇 가지 연산자가 있다. 다들 알고 있듯이 `==`와 `=`은 다르다. 그렇다면 컴파일러는 어떻게 `==`가 `=` 2개가 아니라는 것을, 즉 우리가 다른 것을 원한다는 것을 알 수 있을까? 이 부분에 대해서는 추후 Lexical Analysis 파트를 자세히 다루는 강의에서 이야기 해 보자.

일단 단어를 이해하면 다음 단계는 문장 구조를 이해해는 파싱, 즉 구문 분석 단계를 거친다. 먼저 문장에서 명사, 동사, 형용사와 같은 각 단어의 역할을 파악하고, 파싱을 통해 이 단어들을 주어, 동사, 목적어와 같은 더 높은 수준으로 묶는다. 이는 전체 문장을 형성하며, 아래와 같이 도식화 할 수 있다.

<img src="https://miro.medium.com/max/703/1*-RBblVf3UtvHahXc0QGpmQ.png" alt="eng text lexical analysis">

영문 텍스트 파싱과 프로그램 텍스트 파싱은 매우 유사하며 도식화 한 결과는 다음과 같다.

<img src="https://miro.medium.com/max/599/1*o4MvW-q-TlaZ-UE3nkD_VQ.png" alt="prog text lexical analysis">

# The Economy of Programming Languages
프로그래밍 언어가 어떻게 구현되고 설계되었는지에 대해 살펴보기 전에, 현실에서 언어가 작동하는 방식과 특정 언어가 사용되는, 또는 사용되지 않는 이유에 대해서 이야기 해 보자.
## 왜 그렇게 많은 프로그래밍 언어가 있을까
물론 학년이 올라갈수록 다양한 언어를 경험해보면서 결국 본질은 비슷하다는 것을 알게 되었고, 하나의 언어를 학습하고 나니 이후에는 습득 속도가 점차 빨라졌지만, 처음 컴퓨터공학부에 입학했을 당시에는 상당히 많은 언어가 있다는 것을 알게 되었을 때 ‘언제 이 언어들을 다 배울 수 있을까, 이 많은 것들을 다 배워야 하는걸까?’ 하고 막막해 했던 적이 있다. 아마 다들 한번쯤 **왜 이렇게 많은 언어들이 있는걸까** 의문점을 가진 적이 있을 것이다.
결론부터 말하자면, 프로그래밍을 위한 애플리케이션 도메인이 매우 독특하고 상충되는 요구 사항이 있기 때문이다. 그러니까 모든 프로그래머를 위해 모든 상황에서 모든 것을 수행하는 하나의 언어를 설계하는 것은 매우 어렵다는 뜻이다.

예를 들어,
- 과학적 컴퓨팅(Scientific Computing)에서는 부동 소수점, 배열 연산, 병렬 처리에 대한 지원이 요구됨 → FORTRAN
- 비즈니스 애플리케이션(Business Applications)에서는 끈기와 보고서 생성 및 데이터 분석 기능이 필요함 → SQL
- 시스템 프로그래밍(System Programming)에서는 자원의 제어, 실시간 제약에 대한 처리가 필요함 → C/C++

즉, **언어마다 중요하게 생각하는 부분, 다시 말해 충족하는 요구사항이 다 다르며, 하나의 언어로 모든 것을 구현하는 것은 쉽지 않기 때문**에 많은 언어들이 존재하는 것이다.
## 새로운 프로그래밍 언어가 생겨나는 이유
그렇다면 이미 많은 언어가 있는데도 불구하고 여전히 새로운 프로그래밍 언어가 생겨나는 이유는 무엇일까?
1. 프로그래밍 언어를 위해 들이는 프로그래머 **훈련 비용이 막대**하기 때문
  
  이미 널리 사용되고 있는 언어는 변경사항을 적용하는데 시간이 걸린다. 따라서 생산성과 훈련 비용을 따져봤을 때, 새로운 언어를 만드는 것이 훈련 비용이 없거나 훨씬 적기 때문에 더 빠르게 발전할 수 있다.
  
  또, 앞선 필자의 경험과 마찬가지로 많은 분들이 언어를 배울 때마다 느끼셨겠지만, 새로운 언어라는 것이 정말 완전히 새로운 경우는 거의 없다. 기존에 존재하는 언어와 유사한 점이 많다는 것이다. 왜 그럴까? 그저 편하게 생각해보면 새로운 것을 생각하고 설계한다는 것 자체가 사실 꽤나 어렵다. 경제적인 측면에서 생각해보면, 기존 언어와 유사한 점이 많기 때문에 훈련 비용을 상당히 절감할 수 있고 사람들도 더 빨리 배울 수 있다.

2. 새로운 애플리케이션 도메인이 등장에 따라 생기는 빈 자리를 채우기 위함

  앞의 질문에서 말했듯이, 언어마다 중점적으로 다루는 기능이 다르기 때문에 기존의 언어로 채우지 못하는 부분을 새로운 언어를 만들어 충족시키는 것이다.
## 좋은 프로그래밍 언어란?
‘좋다’ 라는 단어는 주관적이기 때문에 명확하게 어떤 언어가 좋은 언어이다라고 모두가 수용하기는 어렵다. 어떤 것이 더 낫다라고 판단하는 기준이나 수치가 없기 때문에 보편적인 합의를 이룰 수 없다.

단편적으로 생각하면 좋은 언어는 많은 사람들이 사용하는 언어이지 않을까? 하고 생각할 수도 있겠다. 좋으니까 인기가 있고 널리 쓰인다는 것은 충분히 그럴 수 있기는 하지만, 프로그래밍 언어가 널리 쓰이는데는 기술적인 우수함 외에도 더 나은 언어가 없어서 사용할 수 밖에 없는 틈새 시장이나 애플리케이션 도메인 지원 여부가 언어 선택에 있어 더 많은 영향을 끼친다. 그리고 어느 정도 자리를 잡고 사용자가 많아지기 시작하면 물건을 구매할 때 베스트 또는 스테디 셀러를 선택하게 되는 것과 마찬가지로 지속적으로 이용자가 증가하는 관성이 생긴다. 이것이 오늘날 다시 설계하면 더 나음에도 불구하고 여전히 FORTRAN과 Cobalt를 비롯하여 많은 오래된 언어들을 사용하는 이유이다.
<hr>
여기까지 1강을 간략하게 정리해보았다. 다음에는 Cool의 개요와 예제를 살펴보도록 하겠다.
